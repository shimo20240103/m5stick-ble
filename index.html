<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>M5StickC 足組み判定（合成値ベース・自動閾値＆プロトタイプ）</title>
  <style>
    body { font-family: 'Arial', sans-serif; background:#eaf7f3; color:#004d40; text-align:center; margin:0; padding:0; }
    h1 { background:#a7ffeb; margin:0; padding:18px 0; border-bottom-left-radius:14px; border-bottom-right-radius:14px; }
    .controls { margin:12px 0; }
    button { font-size:15px; padding:8px 16px; margin:6px; border-radius:8px; border:none; background:#26a69a; color:#fff; cursor:pointer;}
    #status1,#status2,#result,#styleLabel,#calibStatus,#thMag { margin-top:10px; font-weight:bold; font-size:18px; display:block; }
    pre { display:inline-block; background:#b2dfdb; padding:8px 14px; border-radius:10px; margin-top:10px; }
    canvas{ border:2px solid #004d40; border-radius:10px; background:#e0f2f1; display:block; margin:8px auto; }
    .graph-container{ margin:18px auto; width:640px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body>
<h1>M5StickC 足組み判定（合成値ベース・自動閾値＆プロトタイプ）</h1>

<div class="controls">
  <button id="connectBtn1" onclick="connect(1)">右足 接続</button>
  <button id="connectBtn2" onclick="connect(2)">左足 接続</button>
  <button onclick="startCalibration()">初期値キャリブレーション</button>
  <button onclick="downloadExcel()">Excelダウンロード</button>
</div>

<div id="status1">右足: 未接続</div>
<pre id="values1">Mag:0.00</pre>

<div id="status2">左足: 未接続</div>
<pre id="values2">Mag:0.00</pre>

<div id="calibStatus">初期値: 未キャリブレーション</div>
<div id="thMag">合成値閾値: —</div>

<div id="result">⚪ 足組み状態: 不明</div>
<div id="styleLabel">組み方: —</div>

<div class="graph-container"><h2>右足 合成値</h2><canvas id="graph1" width="640" height="140"></canvas></div>
<div class="graph-container"><h2>左足 合成値</h2><canvas id="graph2" width="640" height="140"></canvas></div>

<script>
/* ---------- BLE定義 ---------- */
const serviceUUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const charUUID    = "beb5483e-36e1-4688-b7f5-ea073f74076a";

let devices = {};
let latestRight = [0,0];
let latestLeft  = [0,0];

let accelData = [["Time","Right_Mag","Left_Mag"]];
let dataStore = {1:[],2:[]};
const maxDataPoints = 300;

/* キャリブレーション */
let calibRight = {pitch:0, roll:0};
let calibLeft  = {pitch:0, roll:0};
let isCalibrated = false;
let tempRight = [];
let tempLeft  = [];

/* 自動閾値とプロトタイプ */
let THRESH_MAG = 50; 
let PROTOTYPES = { "15":50, "45":80, "90":120 };

/* ---------- BLE接続 ---------- */
async function connect(id){
  const btn = document.getElementById("connectBtn"+id);
  btn.disabled = true;

  try{
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices:true,
      optionalServices:[serviceUUID]
    });

    devices[id] = device;
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService(serviceUUID);
    const char = await service.getCharacteristic(charUUID);

    await char.startNotifications();
    char.addEventListener("characteristicvaluechanged", e=>{
      const text = new TextDecoder().decode(e.target.value).trim();
      const parts = text.split(",");

      if(parts.length >= 2){
        const pitch = parseFloat(parts[0]);
        const roll  = parseFloat(parts[1]);
        const mag   = Math.hypot(pitch, roll);

        if(id === 1){
          latestRight = [pitch, roll];
          document.getElementById("values1").textContent = `Mag:${mag.toFixed(2)}`;
          dataStore[1].push(mag);
          if(dataStore[1].length > maxDataPoints) dataStore[1].shift();
          drawGraph(1);
        } else {
          latestLeft = [pitch, roll];
          document.getElementById("values2").textContent = `Mag:${mag.toFixed(2)}`;
          dataStore[2].push(mag);
          if(dataStore[2].length > maxDataPoints) dataStore[2].shift();
          drawGraph(2);
        }

        const rightMag = Math.hypot(latestRight[0], latestRight[1]);
        const leftMag  = Math.hypot(latestLeft[0], latestLeft[1]);
        accelData.push([
          new Date().toLocaleTimeString(),
          rightMag.toFixed(2),
          leftMag.toFixed(2)
        ]);

        checkLegCrossed();
      }
    });

    document.getElementById("status"+id).textContent =
      `✅ ${id===1 ? "右足" : "左足"} 接続成功`;
  }
  catch(err){
    document.getElementById("status"+id).textContent = "❌ 接続失敗: " + err;
    btn.disabled = false;
  }
}

/* ---------- キャリブレーション ---------- */
function startCalibration(){
  tempRight = [];
  tempLeft  = [];
  isCalibrated = false;
  let sec = 10;
  document.getElementById("calibStatus").textContent = `キャリブレーション開始…${sec}秒`;

  let timer = setInterval(()=>{
    sec--;
    tempRight.push([...latestRight]);
    tempLeft.push([...latestLeft]);
    document.getElementById("calibStatus").textContent = `キャリブレーション中…${sec}秒`;

    if(sec <= 0){
      clearInterval(timer);

      calibRight.pitch = avg(tempRight.map(v=>v[0]));
      calibRight.roll  = avg(tempRight.map(v=>v[1]));
      calibLeft.pitch  = avg(tempLeft.map(v=>v[0]));
      calibLeft.roll   = avg(tempLeft.map(v=>v[1]));

      // 自動閾値とプロトタイプ計算
      const magDiffs = tempRight.map((v,i)=>{
        const rMag = Math.hypot(v[0]-calibRight.pitch, v[1]-calibRight.roll);
        const lMag = Math.hypot(tempLeft[i][0]-calibLeft.pitch, tempLeft[i][1]-calibLeft.roll);
        return Math.abs(rMag-lMag);
      });

      const mean = avg(magDiffs);
      const std  = Math.sqrt(avg(magDiffs.map(d => (d-mean)**2)));
      THRESH_MAG = mean + 1.5*std;

      // プロトタイプも自動設定（25%,50%,75%分位で）
      PROTOTYPES = {
        "15": quantile(magDiffs,0.25),
        "45": quantile(magDiffs,0.5),
        "90": quantile(magDiffs,0.75)
      };

      document.getElementById("calibStatus").textContent =
        `初期値設定完了：右(P:${calibRight.pitch.toFixed(1)},R:${calibRight.roll.toFixed(1)}) / 左(P:${calibLeft.pitch.toFixed(1)},R:${calibLeft.roll.toFixed(1)})`;
      document.getElementById("thMag").textContent = `合成値閾値: ${THRESH_MAG.toFixed(2)}`;
      isCalibrated = true;
    }
  },1000);
}

function avg(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
function quantile(arr,q){
  const sorted = arr.slice().sort((a,b)=>a-b);
  const pos = (sorted.length-1)*q;
  const base = Math.floor(pos);
  const rest = pos-base;
  if(sorted[base+1] !== undefined) return sorted[base] + rest*(sorted[base+1]-sorted[base]);
  else return sorted[base];
}

/* ---------- 足組み判定 ---------- */
function computeAngleLevel(){
  if(!isCalibrated) return 0;

  const rightMag = Math.hypot(latestRight[0]-calibRight.pitch, latestRight[1]-calibRight.roll);
  const leftMag  = Math.hypot(latestLeft[0]-calibLeft.pitch, latestLeft[1]-calibLeft.roll);

  const diffMag = Math.abs(rightMag - leftMag);
  if(diffMag < THRESH_MAG) return 0;

  // プロトタイプ比較
  let best = null, bestDist = Infinity;
  for(const label in PROTOTYPES){
    const dist = Math.abs(diffMag-PROTOTYPES[label]);
    if(dist<bestDist){ bestDist = dist; best=label; }
  }
  return parseInt(best);
}

function checkLegCrossed(){
  if(!isCalibrated){
    document.getElementById("result").textContent = "⚠ キャリブレーション未実施";
    return;
  }
  const angle = computeAngleLevel();
  const resultEl = document.getElementById("result");
  const styleEl  = document.getElementById("styleLabel");

  if(angle===0){
    resultEl.textContent = "✅ 足を組んでいません";
    resultEl.style.background="#c8e6c9";
    styleEl.textContent="組み方: —";
  } else {
    resultEl.textContent = "⚠ 足を組んでいます";
    resultEl.style.background="#ffccbc";
    styleEl.textContent=`組み方: ${angle}°（推定）`;
  }
}

/* ---------- グラフ描画 ---------- */
function drawGraph(id){
  const ctx = document.getElementById("graph"+id).getContext("2d");
  const data = dataStore[id];
  const w = ctx.canvas.width, h = ctx.canvas.height;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#e0f2f1";
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle="#004d40";
  ctx.beginPath();
  ctx.moveTo(0,h/2);
  ctx.lineTo(w,h/2);
  ctx.stroke();

  if(data.length<2) return;

  let maxVal = Math.max(...data.map(v=>Math.abs(v)));
  let scale = (h/2-8)/(maxVal||1);

  ctx.strokeStyle = id===1 ? "#ff5252":"#2979ff";
  ctx.beginPath();
  data.forEach((v,i)=>{
    const x=(i/(maxDataPoints-1))*w;
    const y=h/2 - v*scale;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
}

/* ---------- Excel 出力 ---------- */
function downloadExcel(){
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(accelData);
  XLSX.utils.book_append_sheet(wb, ws, "MagData");
  XLSX.writeFile(wb,"accel_mag.xlsx");
}
</script>
</body>
</html>
