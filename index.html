<script>
/* ---------- 固定の閾値 ---------- */
const THRESH_PITCH = 26.42;
const THRESH_ROLL  = 46.39;

/* プロトタイプ（ΔPitch, ΔRoll） */
const PROTOTYPES = {
  "15": {dp: 28.85, dr: 72.91},
  "45": {dp: 31.46, dr: 55.65},
  "90": {dp: 19.92, dr:119.74}
};

/* UI 表示 */
document.addEventListener("DOMContentLoaded", ()=>{
  document.getElementById("thP").textContent = THRESH_PITCH.toFixed(2);
  document.getElementById("thR").textContent = THRESH_ROLL.toFixed(2);
});

const serviceUUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const charUUID    = "beb5483e-36e1-4688-b7f5-ea073f74076a";

let devices = {};
let latestRight = [0,0];
let latestLeft  = [0,0];
let accelData = [["Time","Right_Pitch","Right_Roll","Left_Pitch","Left_Roll"]];
let dataStore = {1:[],2:[]};
const maxDataPoints = 300;

/* ---------- キャリブレーション用 ---------- */
let calibRight = {pitch:0, roll:0};
let calibLeft  = {pitch:0, roll:0};
let isCalibrated = false;

let tempRight = [];
let tempLeft  = [];

/* BT 接続 */
async function connect(id){
  const btn = document.getElementById("connectBtn"+id);
  btn.disabled = true;

  try{
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices:true,
      optionalServices:[serviceUUID]
    });

    devices[id] = device;
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService(serviceUUID);
    const char = await service.getCharacteristic(charUUID);

    await char.startNotifications();
    char.addEventListener("characteristicvaluechanged", e=>{
      const text = new TextDecoder().decode(e.target.value).trim();
      const parts = text.split(",");

      if(parts.length >= 2){
        const pitch = parseFloat(parts[0]);
        const roll  = parseFloat(parts[1]);

        if(id === 1){
          latestRight = [pitch, roll];
          document.getElementById("values1").textContent =
            `Pitch:${pitch.toFixed(2)} Roll:${roll.toFixed(2)}`;
          dataStore[1].push(pitch);
          if(dataStore[1].length > maxDataPoints) dataStore[1].shift();
          drawGraph(1);
        } else {
          latestLeft = [pitch, roll];
          document.getElementById("values2").textContent =
            `Pitch:${pitch.toFixed(2)} Roll:${roll.toFixed(2)}`;
          dataStore[2].push(pitch);
          if(dataStore[2].length > maxDataPoints) dataStore[2].shift();
          drawGraph(2);
        }

        accelData.push([
          new Date().toLocaleTimeString(),
          latestRight[0], latestRight[1],
          latestLeft[0], latestLeft[1]
        ]);

        checkLegCrossed();
      }
    });

    document.getElementById("status"+id).textContent =
      `✅ ${id===1 ? "右足" : "左足"} 接続成功`;
  }
  catch(err){
    document.getElementById("status"+id).textContent = "❌ 接続失敗: " + err;
    btn.disabled = false;
  }
}

/* ---------- キャリブレーション開始 ---------- */
function startCalibration(){
  tempRight = [];
  tempLeft  = [];
  isCalibrated = false;

  let sec = 10;
  document.getElementById("calibStatus").textContent =
    `キャリブレーション開始… ${sec}秒`;

  let timer = setInterval(()=>{
    sec--;

    tempRight.push([...latestRight]);
    tempLeft.push([...latestLeft]);

    document.getElementById("calibStatus").textContent =
      `キャリブレーション中… ${sec}秒`;

    if(sec <= 0){
      clearInterval(timer);

      calibRight.pitch = avg(tempRight.map(v=>v[0]));
      calibRight.roll  = avg(tempRight.map(v=>v[1]));

      calibLeft.pitch  = avg(tempLeft.map(v=>v[0]));
      calibLeft.roll   = avg(tempLeft.map(v=>v[1]));

      isCalibrated = true;

      document.getElementById("calibStatus").textContent =
        `初期値設定完了：右(P:${calibRight.pitch.toFixed(1)},R:${calibRight.roll.toFixed(1)}) / 左(P:${calibLeft.pitch.toFixed(1)},R:${calibLeft.roll.toFixed(1)})`;
    }
  }, 1000);
}

function avg(arr){ return arr.reduce((a,b)=>a+b,0) / arr.length; }

/* =========================================================
      足組み判定（方式B：左右それぞれの初期値との差で判定）
========================================================= */
function checkLegCrossed(){
  if(!isCalibrated){
    document.getElementById("result").textContent = "⚠ キャリブレーション未実施";
    return;
  }

  /* 右足との差分 */
  const rP = latestRight[0] - calibRight.pitch;
  const rR = latestRight[1] - calibRight.roll;

  /* 左足との差分 */
  const lP = latestLeft[0] - calibLeft.pitch;
  const lR = latestLeft[1] - calibLeft.roll;

  const resultEl = document.getElementById("result");
  const styleEl  = document.getElementById("styleLabel");

  /* ---------- 判定（ピッチ & ロール両方満たす時だけ検知） ---------- */

  // 右足が上の 90°
  if(rP <= -70 && rR <= -95){
    resultEl.textContent = "⚠ 足を組んでいます（右 90°）";
    resultEl.style.background = "#ffccbc";
    styleEl.textContent = "組み方: 右 90°";
    return;
  }

  // 右足 45°
  if(rP <= -25 && rR <= -20){
    resultEl.textContent = "⚠ 足を組んでいます（右 45°）";
    resultEl.style.background = "#ffccbc";
    styleEl.textContent = "組み方: 右 45°";
    return;
  }

  // 左足が上の 90°
  if(lP <= -70 && lR <= -95){
    resultEl.textContent = "⚠ 足を組んでいます（左 90°）";
    resultEl.style.background = "#ffccbc";
    styleEl.textContent = "組み方: 左 90°";
    return;
  }

  // 左足 45°
  if(lP <= -25 && lR <= -20){
    resultEl.textContent = "⚠ 足を組んでいます（左 45°）";
    resultEl.style.background = "#ffccbc";
    styleEl.textContent = "組み方: 左 45°";
    return;
  }

  /* どれにも当てはまらなければ非組み */
  resultEl.textContent = "✅ 足を組んでいません";
  resultEl.style.background = "#c8e6c9";
  styleEl.textContent = "組み方: —";
}

/* ---------- グラフ描画（Pitchのみ） ---------- */
function drawGraph(id){
  const ctx = document.getElementById("graph"+id).getContext("2d");
  const data = dataStore[id];
  const w = ctx.canvas.width, h = ctx.canvas.height;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#e0f2f1";
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle="#004d40";
  ctx.beginPath();
  ctx.moveTo(0,h/2);
  ctx.lineTo(w,h/2);
  ctx.stroke();

  if(data.length < 2) return;

  let maxVal = Math.max(...data.map(v=>Math.abs(v)));
  let scale = (h/2 - 8) / (maxVal || 1);

  ctx.strokeStyle = id===1 ? "#ff5252" : "#2979ff";
  ctx.beginPath();
  data.forEach((v,i)=>{
    const x = (i/(maxDataPoints-1))*w;
    const y = h/2 - v*scale;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
}

/* ---------- Excel出力 ---------- */
function downloadExcel(){
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(accelData);
  XLSX.utils.book_append_sheet(wb, ws, "PitchRoll");
  XLSX.writeFile(wb, "accel_pitch_roll_with_timestamps.xlsx");
}
</script>
